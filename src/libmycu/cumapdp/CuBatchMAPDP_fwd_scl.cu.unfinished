/***************************************************************************
 *   Copyright (C) 2013-2019 Mindaugas Margelevicius                       *
 *   Institute of Biotechnology, Vilnius University                        *
 ***************************************************************************/

#include "liblib/mybase.h"
#include "libmycu/cucom/cucommon.h"
#include "libmycu/cupro/PM2DVectorFields.h"
#include "libmycu/cupro/CuBatchProcessing_com.cuh"
#include "libmycu/cusco/CuBatchScoreMatrix_com.h"
#include "libmycu/cudp/CuBatchDP_com.h"
#include "libmycu/cudp/CuBatchDP_init.cuh"
#include "libmycu/cuss/CuBatchSS_com.h"
#include "CuBatchMAPDP_fwd.cuh"

// #define CUMAPDP_FWD_TESTPRINT 0 //3024//4899

// =========================================================================

// NOTE: parameters are passed to the device via constant memory and are 
// limited to 4 KB
// 
// device functions for executing dynamic programming with backtracking 
// information;
// NOTE: Version for thread block of one warp!
// blkdiagnum, block diagonal serial number;
// lastydiagnum, last block diagonal serial number along y axis 
// (starting at x=-CUMAPDP_2DCACHE_DIM);
// logevthld, log e-value threshold;
// ndb1pros, number of profiles in the first profile data buffer db1;
// querprosOmtd, number of query profiles up to this query profile;
// ndb1prosOmtd, number of profiles missed up to the first one in db1;
// ndbCprosOmtd, number of profiles missed up to the first one in dbC;
// nqyposs, number of query positions to process;
// ndb1poss, number of cached db profile positions to process;
// ndbCposs, number of new db profile positions to process;
// dbxpad, number of padded positions for memory alignment;
// querposoffset, offset from the origin of the device buffers allocated for 
// queries;
// bdb1posoffset, offset from the origin of the device buffers allocated for 
// cached db profile data;
// bdbCposoffset, offset from the origin of the device buffers allocated for 
// new (read) db profile data;
// dblen2, total number of db profile positions + padding in phase 2;
//

// DP processing layout:
// +---------===-+--------+--+-
// |  /  /  /  / |  /  /  |  |
// | /  /  /  /  | /  /  /| /|
// |/  /  /  /  /|/  /  / |/ |
// +---======----+---=====+--+-
// |  /  /  /  / |  /  /  |  |
// +=====--------+=====---+--+-
// (double line indicates current parallel processing)

// -------------------------------------------------------------------------
// ExecMAPDP_Fwd_Unroll32x: device code for executing dynamic programming to 
// calculate forward probabilities using shared memory and 32-fold unrolling 
// along the diagonal of dimension CUMAPDP_2DCACHE_DIM;
// NOTE: memory pointers should be aligned!
// scores, calculated scores used as input;
// modscores, input modular scores;
// dp2alndatbuffers, profile-specific statistics from (previous) phase 1;
// tmpdpdiagbuffers, temporary buffers for last calculated diagonal scores;
// tmpdpbotbuffer, temporary buffers for last calculated bottom scores;
// tmpblockprobscales, temporary buffers for block-specific scale factors;
// tmpprobscales, temporary buffers for final rescaled scale factors;
// tmpfwdprobs, output forward probabilities to be adjusted while 
// executing the backward calculations;
// NOTE: 13824B SMEM is a limit of reduced occupancy
// 
__global__ void ExecMAPDP_Fwd_Unroll32x(
    uint blkdiagnum,
    uint lastydiagnum,
    float logevthld,
    uint ndb1pros,
    uint querprosOmtd, uint ndb1prosOmtd, uint ndbCprosOmtd,
    uint nqyposs, uint ndb1poss, uint ndbCposs, uint dbxpad,
    uint querposoffset, uint bdb1posoffset, uint /*bdbCposoffset*/,
    uint dblen2,
    const CUBSM_TYPE* __restrict__ scores,
    const CUBSM_TYPE* __restrict__ modscores,
    const float* __restrict__ dp2alndatbuffers,
    CUBDP_TYPE* __restrict__ tmpdpdiagbuffers,
    CUBDP_TYPE* __restrict__ tmpdpbotbuffer,
    CUBDP_TYPE* __restrict__ tmpblockprobscales, 
    CUBDP_TYPE* __restrict__ tmpprobscales,
    CUBDP_TYPE* __restrict__ tmpfwdprobs )
{
    /*__shared__ */LNTYPE dbprodstCache;//distance in positions to db profile
    /*__shared__ */INTYPE dbprolenCache;//length of profile
    __shared__ FPTYPE 
            qrtrpCache[nTDPUsedProTrn][CUMAPDP_2DCACHE_DIM_D],//cache for query transition probabilities
            dbtrpCache[nTDPUsedProTrn][CUMAPDP_2DCACHE_DIM_DpX];//cache for db transition probabilities
    //cache of scores: use padding of +1 to eliminate bank conflicts when accessing the cache
    __shared__ CUBSM_TYPE
            scoreCache[CUMAPDP_2DCACHE_DIM_D][CUMAPDP_2DCACHE_DIM_X+CUDPIDS];
    __shared__ CUBSM_TYPE //block-specific probability scale factors
            blkscaleCache[CUMAPDP_2DCACHE_DIM_D+1][CUMAPDP_2DCACHE_DIM_X+2+CUDPIDS];
//     __shared__ CUBDP_TYPE //cache of diagonal 1 and 2 for blkscaleCache
//             diag12blkscaleCache[2][CUMAPDP_2DCACHE_DIM_D+1];
    __shared__ CUBDP_TYPE
            diag1Cache[nTDPDiagScoreSubsections][CUMAPDP_2DCACHE_DIM_D+1],//cache for state scores of the 1st diagonal
            diag2Cache[nTDPDiagScoreSubsections][CUMAPDP_2DCACHE_DIM_D+1],//cache for state scores of the last diagonal
            bottmCache[nTDPDiagScoreSubsections][CUMAPDP_2DCACHE_DIM_X];//cache for state scores of the bottom of the diagonals
    //
    CUBDP_TYPE maxprobCache;//maximum probability along query position
    float blkprobscale;//probability scale of a current query position (to be updated)
    float logtotprobscale;//log total probability scale at a position one above the diagonal block
    //
    uint proattr[2];//original profile NUMBER and new DISTANCE from the beginning
    uint dbfldsndx;
    uint pronr;
    float evals[2];//log of e-value and pair e-value


    // blockIdx.y is the profile serial number in phase 2;
    //{{get the original profile number and e-values too
    if( /*threadIdx.y == 0 && */threadIdx.x < 2 ) {
        evals[threadIdx.x] = dp2alndatbuffers[nTDP2OutputAlnData*blockIdx.y+dp2oadEvalue+threadIdx.x];
        proattr[threadIdx.x] = dp2alndatbuffers[nTDP2OutputAlnData*blockIdx.y+dp2oadOrgProNo+threadIdx.x];
    }
    proattr[0] = __shfl_sync(0xffffffff, proattr[0], 0);
    proattr[1] = __shfl_sync(0xffffffff, proattr[1], 1);
    evals[0] = __shfl_sync(0xffffffff, evals[0], 0);
    evals[1] = __shfl_sync(0xffffffff, evals[1], 1);
    //}}

    //all threads exit if calculated e-value exceeds the threshold
    if( logevthld < evals[0])
        return;


    //NOTE: protection against overflow ensured on the host side
    if( proattr[0] < ndb1pros ) { pronr = proattr[0] + ndb1prosOmtd;
                dbfldsndx = pmv2DTotFlds;
    } else {    pronr = proattr[0] - ndb1pros + ndbCprosOmtd;//jump to section ndbCposs
                //bdb1posoffset = bdbCposoffset;
                dbfldsndx = TIMES2(pmv2DTotFlds);
    }

    if( /*threadIdx.y == 0 && */threadIdx.x == 0 ) {
        dbprodstCache = ((LNTYPE*)(dc_pm2dvfields_[dbfldsndx+pps2DDist]))[pronr];
        dbprolenCache = ((INTYPE*)(dc_pm2dvfields_[dbfldsndx+pps2DLen]))[pronr];
    }

    // blockIdx.x is block serial number s within diagonal blkdiagnum;
    // (x,y) is the bottom-left corner (x,y) coordinates for profile proattr[0];
    int x, y;
    if( blkdiagnum <= lastydiagnum) {
        //x=-!(d%2)w+2ws; y=dw/2+w-sw -1 (-1, zero-based indices); [when w==b]
        //(b, block's length; w, block's width)
        x = (2*blockIdx.x - (!(blkdiagnum & 1))) * CUMAPDP_2DCACHE_DIM_D;
        y = ((blkdiagnum>>1) + 1 - blockIdx.x) * CUMAPDP_2DCACHE_DIM_D - 1;
    } else {
        //x=-w+(d-d_l)w+2ws; y=dw/2+w-sw -1; [when w==b]
        x = (2*blockIdx.x + (blkdiagnum-lastydiagnum-1)) * CUMAPDP_2DCACHE_DIM_D;
        y = ((lastydiagnum>>1) + 1 - blockIdx.x) * CUMAPDP_2DCACHE_DIM_D - 1;
    }


    //{{use registers efficiently
    dbprodstCache = __shfl_sync(0xffffffff, dbprodstCache, 0);
    dbprolenCache = __shfl_sync(0xffffffff, dbprolenCache, 0);
    //}}
    //...or use shared memory; bank conflicts arise when accessed
//     __syncthreads();



    //number of iterations for this block to perform;
    //uint makes the compiler to reduce #registers
    uint ilim = GetMaqxNoIterations( x, y, nqyposs, dbprolenCache, CUMAPDP_2DCACHE_DIM_X );

    if( y < 0 || (int)nqyposs <= (int)(y+1 - CUMAPDP_2DCACHE_DIM_D) || 
        (int)dbprolenCache <= x /*+ CUMAPDP_2DCACHE_DIM_DpX */ ||
        ilim < 1 )
        //block does not participate: out of profile boundaries
        return;

    uint qpos = y - threadIdx.x;//going upwards



    if( 0 <= (int)qpos && qpos < nqyposs )
        // (add querprosOmtd vectors of beginning transitions):
        MAPDPLocCacheTrnProbs( qrtrpCache, 0, querposoffset + qpos + querprosOmtd );
    else
        MAPDPLocInitTrnProbs( qrtrpCache );

    //x is now the position this thread will process
    x += threadIdx.x;

    //db profile position corresponding to the diagonal block's bottom-left 
    // corner in the buffers dc_pm2dvfields_:
    uint dbpos = x + dbprodstCache;//going right
    uint dblen = ndb1poss + ndbCposs + dbxpad;

    if( 0 <= x && x < (int)dbprolenCache )
        // (add pronr vectors of beginning transitions):
        MAPDPLocCacheTrnProbs( dbtrpCache, 0, dbfldsndx, dbpos + pronr );
    else
        MAPDPLocInitTrnProbs( dbtrpCache, 0 );

    if( 0 <= (int)(x+blockDim.x) && (int)(x+blockDim.x) < (int)dbprolenCache )
        MAPDPLocCacheTrnProbs( dbtrpCache, blockDim.x, dbfldsndx, dbpos + pronr + blockDim.x );
    else
        MAPDPLocInitTrnProbs( dbtrpCache, blockDim.x );



    //dbpos is now the x position of the diagonal block's bottom-left 
    // corner in the score matrix plus the offset determined by thread id:
    dbpos = (proattr[0] < ndb1pros)? dbpos - bdb1posoffset: dbpos + ndb1poss;
    //dbpos2 is the x position of the diagonal block's bottom-left 
    // corner in the phase-2 diagonal and bottom structures plus the offset 
    // determined by thread id:
    uint dbpos2 = x + proattr[1];



    //read probability scale factors updated at each query position;
    // assume a block's negative bottom-left corner implies the first 
    // block in a row, which is true under the assumption of the block's 
    // width equal to its length
    blkprobscale = 1.0f;
    logtotprobscale = 0.0f;//log of scale==1
    if( 0 < (int)qpos && qpos < nqyposs ) {
        //gridDim.y is the total number of profiles in phase 2
        if( threadIdx.x == CUMAPDP_2DCACHE_DIM_D-1 )
            logtotprobscale = tmpprobscales[(gridDim.y*mapdppsTotScale + blockIdx.y) * nqyposs + qpos-1];
        if( 0 <= x )
            blkprobscale = tmpprobscales[(gridDim.y*mapdppsPosScale + blockIdx.y) * nqyposs + qpos-1];
    }

    logtotprobscale = __shfl_sync(0xffffffff, logtotprobscale, CUMAPDP_2DCACHE_DIM_D-1);

    //read block-specific log of joint (total) scale factors;
    //read the bottom line of the above diagonal block first
    blkscaleCache[CUMAPDP_2DCACHE_DIM_D][threadIdx.x] = logtotprobscale;//log value
    if( 0 < x+CUMAPDP_2DCACHE_DIM_X && x+CUMAPDP_2DCACHE_DIM_X-1 < (int)dbprolenCache && 
        CUMAPDP_2DCACHE_DIM_D <= y )
        blkscaleCache[CUMAPDP_2DCACHE_DIM_D][threadIdx.x] = 
            tmpblockprobscales[(y-CUMAPDP_2DCACHE_DIM_D)*dblen2 + dbpos2+CUMAPDP_2DCACHE_DIM_X-1];
    //diagonal block's left edge:
    if( x-threadIdx.x < 0 ) {
        //the left edge of the block is outside the profile boundaries, 
        // initialize block-specific joint scale factors
        blkscaleCache[threadIdx.x][0] = 
            mywarprevexcprefixsum(__logf(blkprobscale));
    }
    else {
        //read the left edge of blk-spec. scale factors written 
        // in the FIRST row of the block for coalescent read
        blkscaleCache[threadIdx.x][0] = 
            tmpblockprobscales[(y-CUMAPDP_2DCACHE_DIM_D+1)*dblen2 + dbpos2+CUMAPDP_2DCACHE_DIM_X-2] +
            __logf(blkprobscale);
    }



    //dynamic score offset and multiplier
    float dyno, dmul;
    MAPDPGetDynScoreParams( evals[1], &dyno, &dmul );

    //cache scores over the oblique diagonal block
    #pragma unroll 4
    for( int i = 0; i < CUMAPDP_2DCACHE_DIM_D; i++ ) {
        //going upwards
        scoreCache[i][threadIdx.x] = CUBDP_Q(0);
        if( 0 <= y-i && y-i < (int)nqyposs && 0 <= x+i && x+i < (int)dbprolenCache ) {
            //starting position of line i of the oblq. diagonal block in the 
            // score matrix: 
            qpos = (y-i) * dblen + i;
            scoreCache[i][threadIdx.x] = __expf(
                dmul? 
                    scores[qpos+dbpos] - dyno + modscores[qpos+dbpos] * dmul
                :   scores[qpos+dbpos] - dyno
            );
        }
    }



    //cache two diagonals from the previous (along the x axis) diagonal block;
    //the structure of tmpdpdiagbuffers is position-specific (1D, along x-axis)
    if( 0 <= x-1 && x < (int)dbprolenCache ) {
        DPLocCacheBuffer<CUMAPDP_2DCACHE_DIM_D>( diag1Cache, tmpdpdiagbuffers, dbpos2-1, 0, dblen2 );
        DPLocCacheBuffer<CUMAPDP_2DCACHE_DIM_D>( diag2Cache, tmpdpdiagbuffers, dbpos2-1, 
                          dpdssDiag2 * nTDPDiagScoreSubsections * dblen2, 
                          dblen2, 
                          1/*shift*/);
        //cache the buffer of maximum probabilities for a query position here
        qpos = dpdssDiagM * nTDPDiagScoreSubsections * dblen2;
        maxprobCache = tmpdpdiagbuffers[qpos + dbpos2 - 1];
    }
    else {
        DPLocInitCache<CUMAPDP_2DCACHE_DIM_D>(diag1Cache);
        DPLocInitCache<CUMAPDP_2DCACHE_DIM_D>(diag2Cache, 1/*shift*/);
        maxprobCache = CUBDP_Q(0);
    }


    //cache the bottom of the above diagonal blocks;
    //the structure of tmpdpbotbuffer is position-specific (1D, along x-axis)
    if( CUMAPDP_2DCACHE_DIM_D <= y && 
        0 <= x+CUMAPDP_2DCACHE_DIM_D-1 && x+CUMAPDP_2DCACHE_DIM_D-1 < (int)dbprolenCache ) {
        DPLocCacheBuffer<CUMAPDP_2DCACHE_DIM_X>( 
            bottmCache, tmpdpbotbuffer, dbpos2+CUMAPDP_2DCACHE_DIM_D-1, 0, 
                        dblen2 );
    }
    else {
        DPLocInitCache<CUMAPDP_2DCACHE_DIM_X>(bottmCache);
    }


    __syncthreads();


    CUBDP_TYPE (*pdiag1)[CUMAPDP_2DCACHE_DIM_D+1] = diag1Cache;
    CUBDP_TYPE (*pdiag2)[CUMAPDP_2DCACHE_DIM_D+1] = diag2Cache;

    //start calculations for this position with 32x unrolling
    //NOTE: sync inside: do not branch;
    for( int i = 0; i < ilim/*CUMAPDP_2DCACHE_DIM_X*/; i++ ) {
        CUBDP_TYPE val1, val2;//, max;
        float logblkpscale = __logf(blkprobscale);

//         int btck = dpbtckSTOP;
        //
        if( threadIdx.x == blockDim.x-1 ) {
            pdiag1[dpdsssStateMM][threadIdx.x+1] = bottmCache[dpdsssStateMM][i];
            pdiag1[dpdsssStateMI][threadIdx.x+1] = bottmCache[dpdsssStateMI][i];
            pdiag1[dpdsssStateIM][threadIdx.x+1] = bottmCache[dpdsssStateIM][i];
            pdiag1[dpdsssStateDN][threadIdx.x+1] = bottmCache[dpdsssStateDN][i];
            pdiag1[dpdsssStateND][threadIdx.x+1] = bottmCache[dpdsssStateND][i];
        }

        //MM state update (diagonal direction)
        val1  = pdiag2[dpdsssStateMI][threadIdx.x+1] * 
            qrtrpCache[dptrMMp][threadIdx.x] * dbtrpCache[dptrIMp][threadIdx.x+i];
        val1 += pdiag2[dpdsssStateIM][threadIdx.x+1] * 
            qrtrpCache[dptrIMp][threadIdx.x] * dbtrpCache[dptrMMp][threadIdx.x+i];
        val1 += pdiag2[dpdsssStateDN][threadIdx.x+1] * 
            qrtrpCache[dptrDMp][threadIdx.x] * dbtrpCache[dptrMMp][threadIdx.x+i];
        val1 += pdiag2[dpdsssStateND][threadIdx.x+1] * 
            qrtrpCache[dptrMMp][threadIdx.x] * dbtrpCache[dptrDMp][threadIdx.x+i];
        val1 += pdiag2[dpdsssStateMM][threadIdx.x+1] * 
            qrtrpCache[dptrMMp][threadIdx.x] * dbtrpCache[dptrMMp][threadIdx.x+i];
        //padding helps avoid bank conflicts when accessing scores;
        //blkprobscale matches threadIdx.x and scores in the diagonal block;
        val1 = blkprobscale * 
            (__expf(blkscaleCache[threadIdx.x+1][i]) + scoreCache[threadIdx.x][i] * val1);
//         max = val1;
//         if(max) btck = dpbtckDIAG;

        __syncthreads();//last point pdiag2 is used for reading in this iteration

        pdiag2[dpdsssStateMM][threadIdx.x] = val1;//WRITE
        //save forward probabilities in the score cache:
        // the diagonal of scores will not be used in the loop any more
        scoreCache[threadIdx.x][i] = val1;//WRITE
        //save block-specific (log) joint probability scale factors
        blkscaleCache[threadIdx.x][i+2] = 
            blkscaleCache[threadIdx.x+1][i] + logblkpscale;//WRITE
        //max scaled probability
        maxprobCache = myhdmax( maxprobCache, val1 );

        //MI state update (up direction)
        val1  = pdiag1[dpdsssStateMM][threadIdx.x+1] * 
            qrtrpCache[dptrMMp][threadIdx.x] * dbtrpCache[dptrMIc][threadIdx.x+i];
        val1 += pdiag1[dpdsssStateMI][threadIdx.x+1] * 
            qrtrpCache[dptrMMp][threadIdx.x] * dbtrpCache[dptrIIc][threadIdx.x+i];
        val1 *= blkprobscale;
        pdiag2[dpdsssStateMI][threadIdx.x] = val1;//WRITE
//         myhdmaxassgn( max, val1, btck, (int)dpbtckUP );

        //IM state update (left direction)
        val1  = pdiag1[dpdsssStateMM][threadIdx.x] * 
            qrtrpCache[dptrMIc][threadIdx.x] * dbtrpCache[dptrMMp][threadIdx.x+i];
        val1 += pdiag1[dpdsssStateIM][threadIdx.x] * 
            qrtrpCache[dptrIIc][threadIdx.x] * dbtrpCache[dptrMMp][threadIdx.x+i];
        //max scales from the above diagonal blocks are used and represent 
        // approximation to scaling probabilities on the left
        if( i < 1 ) val1 *= blkprobscale;
        pdiag2[dpdsssStateIM][threadIdx.x] = val1;//WRITE
//         myhdmaxassgn( max, val1, btck, (int)dpbtckLEFT );

        //DN state update (up)
        val1  = pdiag1[dpdsssStateMM][threadIdx.x+1] * qrtrpCache[dptrMDp][threadIdx.x];
        val1 += pdiag1[dpdsssStateDN][threadIdx.x+1] * qrtrpCache[dptrDDp][threadIdx.x];
        val1 *= blkprobscale;
        pdiag2[dpdsssStateDN][threadIdx.x] = val1;//WRITE
//         myhdmaxassgn( max, val1, btck, (int)dpbtckUP );

        //ND state update (left)
        val1  = pdiag1[dpdsssStateMM][threadIdx.x] * dbtrpCache[dptrMDp][threadIdx.x+i];
        val1 += pdiag1[dpdsssStateND][threadIdx.x] * dbtrpCache[dptrDDp][threadIdx.x+i];
        //max scales from the above diagonal blocks are used and represent 
        // approximation to scaling probabilities on the left
        if( i < 1 ) val1 *= blkprobscale;
        pdiag2[dpdsssStateND][threadIdx.x] = val1;//WRITE
//         myhdmaxassgn( max, val1, btck, (int)dpbtckLEFT );

//         btckCache[threadIdx.x][i] = btck;

        if( threadIdx.x == 0 ) {
            //WRITE
            //this position is not used by other threads in the current iteration
            bottmCache[dpdsssStateMM][i] = pdiag2[dpdsssStateMM][threadIdx.x];
            bottmCache[dpdsssStateMI][i] = pdiag2[dpdsssStateMI][threadIdx.x];
            bottmCache[dpdsssStateIM][i] = pdiag2[dpdsssStateIM][threadIdx.x];
            bottmCache[dpdsssStateDN][i] = pdiag2[dpdsssStateDN][threadIdx.x];
            bottmCache[dpdsssStateND][i] = pdiag2[dpdsssStateND][threadIdx.x];
        }

#ifdef CUMAPDP_INIT_BTCK_TESTPRINT
        if(pronr==CUMAPDP_INIT_BTCK_TESTPRINT){
            printf(" d=%u(%u) s=%u i%02d/%u (t%02u): len= %d addr= %u SC= %.4f (yx: %d,%d) "
                    "MM= %.6f MI= %.6f IM= %.6f DN= %.6f ND= %.6f  MAX= %.6f\n"
                    "  >qMM= %.4f qMIc= %.4f qMD= %.4f qIM= %.4f qIIc= %.4f qDM= %.4f qDD= %.4f\n"
                    "  >dMM= %.4f dMIc= %.4f dMD= %.4f dIM= %.4f dIIc= %.4f dDM= %.4f dDD= %.4f\n",
                    blkdiagnum,lastydiagnum,blockIdx.x,i,ilim,threadIdx.x,
                    dbprolenCache,dbprodstCache,scoreCache[threadIdx.x][i], y-threadIdx.x,x+i,
                    pdiag2[dpdsssStateMM][threadIdx.x],
                    pdiag2[dpdsssStateMI][threadIdx.x],
                    pdiag2[dpdsssStateIM][threadIdx.x],
                    pdiag2[dpdsssStateDN][threadIdx.x],
                    pdiag2[dpdsssStateND][threadIdx.x],
                    maxprobCache, 
                    qrtrpCache[dptrMMp][threadIdx.x],qrtrpCache[dptrMIc][threadIdx.x],
                    qrtrpCache[dptrMDp][threadIdx.x],qrtrpCache[dptrIMp][threadIdx.x],
                    qrtrpCache[dptrIIc][threadIdx.x],qrtrpCache[dptrDMp][threadIdx.x],
                    qrtrpCache[dptrDDp][threadIdx.x],
                    dbtrpCache[dptrMMp][threadIdx.x+i],dbtrpCache[dptrMIc][threadIdx.x+i],
                    dbtrpCache[dptrMDp][threadIdx.x+i],dbtrpCache[dptrIMp][threadIdx.x+i],
                    dbtrpCache[dptrIIc][threadIdx.x+i],dbtrpCache[dptrDMp][threadIdx.x+i],
                    dbtrpCache[dptrDDp][threadIdx.x+i]
            );
            for(size_t _k=0;_k<1000000000UL;_k++)clock();
            for(size_t _k=0;_k<1000000000UL;_k++)clock();
        }
#endif

        myhdswap( pdiag1, pdiag2 );

        __syncthreads();
    }


//     //XOR mode warp sync for butterfly reduction;
//     //NOTE: too expensive to perform for each block; 
//     // this synchronization is only needed for the last block;
//     // thus, skip this step altogether;
//     for(int i = 16/*warpSize>>1*/; 1 <= i; i >>= 1 )
//         maxscCache = myhdmax( maxscCache, __shfl_xor_sync(0xffffffff, maxscCache, i/*, 32*//*warpsize*/));

#ifdef CUMAPDP_INIT_BTCK_TESTPRINT
        if(pronr==CUMAPDP_INIT_BTCK_TESTPRINT)
            printf(" >>> d=%u(%u) s=%u (t%02u): MAX= %.6f COORD= %x wrt= %d xpos= %d\n", 
                    blkdiagnum,lastydiagnum,blockIdx.x,threadIdx.x, 
                    maxscCache, maxscCoords, x+CUMAPDP_2DCACHE_DIM_X-1<(int)dbprolenCache, 
                    x+CUMAPDP_2DCACHE_DIM_X-1);
#endif


    //write the result of calculations for following blocks;
    //write two diagonals;
    if( 0 <= x+CUMAPDP_2DCACHE_DIM_X-1 && x+CUMAPDP_2DCACHE_DIM_X-1 < (int)dbprolenCache ) {
        DPLocWriteBuffer( diag1Cache, tmpdpdiagbuffers, dbpos+CUMAPDP_2DCACHE_DIM_X-1, 0, 
                          dblen );
        DPLocWriteBuffer( diag2Cache, tmpdpdiagbuffers, dbpos+CUMAPDP_2DCACHE_DIM_X-1, 
                          dpdssDiag2 * nTDPDiagScoreSubsections * dblen, 
                          dblen,
                          1/*shift*/);
    }

    uint ndx = CUMAPDP_2DCACHE_DIM_X-1;
    int xtl = x-threadIdx.x+blockDim.x-1;//top-left x coordinate of the diagonal block
    if( xtl >= (int)dbprolenCache )
        ndx = 0U;
    else if( xtl+ndx >= (int)dbprolenCache )
        ndx = dbprolenCache - xtl - 1;

    //write the buffer of maximum scores
    if( 0 <= (int)(x+ndx) ) {//&& (int)(x+ndx) < (int)dbprolenCache ) {
        qpos = dpdssDiagM * nTDPDiagScoreSubsections * dblen;
        //tmpdpdiagbuffers[qpos + dbpos+ndx] = maxscCache[threadIdx.x];
        if( CUMAPDP_2DCACHE_DIM_D <= y ) {
            if( tmpdpdiagbuffers[qpos + dbpos+ndx] < maxscCache ) {
                tmpdpdiagbuffers[qpos + dbpos+ndx] = maxscCache;
                maxscoordsbuf[dbpos+ndx] = maxscCoords;
            }
        } else {
            tmpdpdiagbuffers[qpos + dbpos+ndx] = maxscCache;
            maxscoordsbuf[dbpos+ndx] = maxscCoords;
        }
    }

    //write the bottom of the diagonal block;
    if( 0 <= x && x < (int)dbprolenCache )
        DPLocWriteBuffer( bottmCache, tmpdpbotbuffer, dbpos, 0, dblen );

    //write backtracking information
    //unroll since #registers is not a problem over all compute capabilities
    #pragma unroll 8
    for( int i = 0; i < CUMAPDP_2DCACHE_DIM_D; i++ ) {
        //going upwards
        if( 0 <= y-i && y-i < (int)nqyposs && 0 <= x+i && x+i < (int)dbprolenCache ) {
            //starting position of line i of the oblq. diagonal block in the matrix:
            qpos = (y-i) * dblen + i;
            btckdata[qpos + dbpos] = btckCache[i][threadIdx.x];
        }
    }
}
